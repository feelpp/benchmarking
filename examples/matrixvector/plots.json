{
    "contents": [
        {
            "type": "section",
            "title": "Description",
            "contents": [
                {
                    "type": "text",
                    "text": "This report analyzes the performance of matrix-vector multiplication for different matrix sizes (N) and levels of task parallelism. We compare fill and compute phases and evaluate how execution time and speedup evolve with increasing workloads."
                },{
                    "type":"section",
                    "title":"Session",
                    "contents":[
                        {
                            "type":"itemize",
                            "ref":"reframe_json",
                            "items":[
                                "Hostname: @{session_info.hostname}@",
                                "User: @{session_info.hostname}@",
                                "Time Start: @{session_info.time_start}@",
                                "Time End: @{session_info.time_end}@"
                            ]
                        }
                    ]
                },
                {
                    "type":"section",
                    "title":"Cases",
                    "contents":[
                        {
                            "type":"itemize",
                            "ref":"reframe_json",
                            "items":[
                                "Total: @{session_info.num_cases}@ ",
                                "Failures: @{session_info.num_failures}@",
                                "Runs: @{runs | length}@"
                            ]
                        }
                    ]
                }
            ]
        },
        {
            "type":"section",
            "title":"Parametrization",
            "contents":[
                {
                    "type":"table",
                    "ref": "reframe_df",
                    "layout":{
                        "rename":{
                            "testcases.time_total":"Total Time (s)",
                            "testcases.hashcode":"Hash",
                            "result":"",
                            "logs_link":""
                        },
                        "column_order":["result","testcases.hashcode","tasks", "elements", "testcases.time_total","logs_link"]
                    },
                    "style":{
                        "column_align":{ "result":"center" },
                        "column_width":{ "result":1,"logs_link":1},
                        "classnames":["scrollable","sortable"]
                    },
                    "filter":{ "placeholder":"Filter testcases..." }
                }
            ]
        },
        {
            "type": "section",
            "title": "Performance Analysis",
            "contents": [
                {
                    "type": "section",
                    "title": "Execution Time vs Number of Tasks",
                    "contents": [
                        {
                            "type": "plot",
                            "plot": {
                                "title": "Performance",
                                "plot_types": [ "scatter", "stacked_bar", "grouped_bar" ],
                                "xaxis": { "parameter": "tasks", "label": "Number of tasks" },
                                "yaxis": { "label": "Execution time (s)" },
                                "color_axis": { "filter": [ { "elapsed_fill": "Fill", "elapsed_compute": "Compute" } ] },
                                "secondary_axis": { "parameter": "elements", "label": "N" }
                            }
                        },
                        {
                            "type": "text",
                            "text": "This plot shows the execution time breakdown (fill and compute stages) as the number of tasks increases. It highlights parallel scaling behavior for different matrix sizes."
                        }
                    ]
                },
                {
                    "type": "section",
                    "title": "Execution Time vs Problem Size (N)",
                    "contents": [
                        {
                            "type": "plot",
                            "plot": {
                                "title": "Absolute performance",
                                "plot_types": [ "scatter", "stacked_bar", "grouped_bar" ],
                                "xaxis": { "parameter": "elements", "label": "N" },
                                "yaxis": { "label": "Execution time (s)" },
                                "color_axis": { "filter": [ { "elapsed_fill": "Fill", "elapsed_compute": "Compute" } ] },
                                "secondary_axis": { "parameter": "tasks", "label": "Number of tasks" }
                            }
                        },
                        {
                            "type": "text",
                            "text": "This plot illustrates how execution time scales with matrix size N under different task counts. It helps identify compute bottlenecks and memory throughput constraints."
                        }
                    ]
                },
                {
                    "type": "section",
                    "title": "Speedup Analysis",
                    "contents": [
                        {
                            "type": "plot",
                            "plot": {
                                "title": "Speedup",
                                "plot_types": [ "scatter" ],
                                "transformation": "speedup",
                                "xaxis": { "parameter": "tasks", "label": "Number of tasks" },
                                "yaxis": { "label": "Speedup" },
                                "color_axis": { "filter": [ { "elapsed_fill": "Fill", "elapsed_compute": "Compute" } ] },
                                "secondary_axis": { "parameter": "elements", "label": "N" }
                            }
                        },
                        {
                            "type": "text",
                            "text": "This speedup plot shows how effectively the computation accelerates when increasing task parallelism. It highlights differences between fill and compute phases and reveals scaling limits for larger matrix sizes."
                        }
                    ]
                }
            ]
        }
    ]
}
