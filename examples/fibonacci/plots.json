{
    "title": "Fibonacci Benchmark Report",
    "description": "Benchmark results for Fibonacci implementations (recursive vs iterative).",
    "content": [
        {
            "type": "section",
            "title": "Description",
            "content": [
                {
                    "type": "text",
                    "text": "This report presents benchmark results for computing Fibonacci numbers using different methods. We compare recursive and iterative implementations for various input sizes."
                }
            ]
        },
        {
            "type": "section",
            "title": "Complexity Analysis",
            "content": [
                {
                    "type": "section",
                    "title": "Time Complexity",
                    "content": [
                        {
                            "type":"plot",
                            "plot":{
                                "title": "Time Complexity",
                                "plot_types": [ "scatter"],
                                "xaxis": { "parameter": "n", "label": "N" },
                                "yaxis": { "label": "Execution time (s)"},
                                "color_axis": { "parameter": "method", "label": "Method"},
                                "aggregations": [{ "column": "perfvalue", "agg": "filter:elapsed" } ]
                            }
                        },
                        {
                            "type": "text",
                            "text": "The plot above shows execution time for each Fibonacci method as a function of input size N. Recursive implementation grows exponentially, while iterative grows linearly."
                        }
                    ]
                },
                {
                    "type":"section",
                    "title":"Speedup Analysis",
                    "content":[
                        {
                            "type":"plot",
                            "plot":{
                                "title": "Speedup (Iterative / Recursive)",
                                "plot_types": [ "scatter"],
                                "transformation":"speedup",
                                "xaxis": { "parameter": "n", "label": "N" },
                                "yaxis": { "label": "Execution time (s)"},
                                "color_axis": { "parameter": "method", "label": "Method"},
                                "aggregations": [{ "column": "perfvalue", "agg": "filter:elapsed" } ]
                            }
                        },
                        {
                        "type": "text",
                        "text": "The speedup plot above shows the relative performance of the iterative method compared to the recursive method. As N increases, the iterative method provides significant speedup over the recursive implementation."
                        }
                    ]
                }
            ]
        },
        {
            "type": "section",
            "title": "Additional Analysis",
            "content": [
                {
                "type": "text",
                "text": "This section can include additional metrics such as memory usage, log-scale performance visualization, or comparisons between multiple Fibonacci implementations."
                }
            ]
        }
    ]
}