= Figures
:page-plotly: true
:page-jupyter: true

In order to generate reports, the _Feel++ benchmarking_ framework requires a figure description to specify what the website report page should contain.

These descriptions should be provided either with a specific JSON file with the structure containing uniquely

[source,json]
----
{
    "plots":[]
}
----

Or by specifying the `plots` field on the benchmark configuration JSON file.

Each figure description should contain the following fields

[source,json]
----
{
    "title": "The figure title",
    "plot_types": [], //List of figure types
    "transformation": "", //Transformation type
    "variables":[], // List of variables to consider
    "names":[], //Respective labels for variables
    "yaxis":{},
    "xaxis":{},
    "color_axis":{}, //Default: performance variables
    "secondary_axis":{}
}
----

Figures will appear in the same order as they appear on the list.

Users can provide multiple plot_types in the same description field.

[NOTE]
====
Only performance variables specified under the `variables` list will be considered. If the list is empty, ALL variables inside the ReFrame report will be taken into account.
====

== Axis
Each axis (with the exception of the `yaxis`) take a `parameter` and a `label` field.
The `yaxis` will contain performance values by default, but it can be overwritten by specifying the `parameter` field.

The `parameter` field of each axis should correspond to either a single dimension parameter specified on the benchmark configuration.
In the case of subparameters, the syntax should be the following: `parameter.subparameter`.

By default, the color axis will contain the performance variables, but this can be customized.

== Transformations

The ReFrame report will be used to create a _Master DataFrame_, which will contain all performance variables and their respective values, as well as all parameters and environments.

To explain how transformation and plot types work, we can consider the following example.

[%dynamic%hide_code,python]
----
records = [{"perfvalue": "elapsed_fill", "value": 28.9239, "unit": "s", "result": "pass", "system": "gaya", "partition": "public", "tasks": 1.0, "elements": 10000.0}, {"perfvalue": "elapsed_compute", "value": 1.92806, "unit": "s", "result": "pass", "system": "gaya", "partition": "public", "tasks": 1.0, "elements": 10000.0}, {"perfvalue": "elapsed_fill", "value": 63.0273, "unit": "s", "result": "pass", "system": "gaya", "partition": "public", "tasks": 1.0, "elements": 20000.0}, {"perfvalue": "elapsed_compute", "value": 3.74504, "unit": "s", "result": "pass", "system": "gaya", "partition": "public", "tasks": 1.0, "elements": 20000.0}, {"perfvalue": "elapsed_fill", "value": 92.358, "unit": "s", "result": "pass", "system": "gaya", "partition": "public", "tasks": 1.0, "elements": 30000.0}, {"perfvalue": "elapsed_compute", "value": 3.29597, "unit": "s", "result": "pass", "system": "gaya", "partition": "public", "tasks": 1.0, "elements": 30000.0}, {"perfvalue": "elapsed_fill", "value": 99.9142, "unit": "s", "result": "pass", "system": "gaya", "partition": "public", "tasks": 1.0, "elements": 40000.0}, {"perfvalue": "elapsed_compute", "value": 2.37914, "unit": "s", "result": "pass", "system": "gaya", "partition": "public", "tasks": 1.0, "elements": 40000.0}, {"perfvalue": "elapsed_fill", "value": 24.8636, "unit": "s", "result": "pass", "system": "gaya", "partition": "public", "tasks": 2.0, "elements": 10000.0}, {"perfvalue": "elapsed_compute", "value": 0.629236, "unit": "s", "result": "pass", "system": "gaya", "partition": "public", "tasks": 2.0, "elements": 10000.0}, {"perfvalue": "elapsed_fill", "value": 14.9139, "unit": "s", "result": "pass", "system": "gaya", "partition": "public", "tasks": 2.0, "elements": 20000.0}, {"perfvalue": "elapsed_compute", "value": 0.498528, "unit": "s", "result": "pass", "system": "gaya", "partition": "public", "tasks": 2.0, "elements": 20000.0}, {"perfvalue": "elapsed_fill", "value": 98.9536, "unit": "s", "result": "pass", "system": "gaya", "partition": "public", "tasks": 2.0, "elements": 30000.0}, {"perfvalue": "elapsed_compute", "value": 2.3708, "unit": "s", "result": "pass", "system": "gaya", "partition": "public", "tasks": 2.0, "elements": 30000.0}, {"perfvalue": "elapsed_fill", "value": 45.4764, "unit": "s", "result": "pass", "system": "gaya", "partition": "public", "tasks": 2.0, "elements": 40000.0}, {"perfvalue": "elapsed_compute", "value": 1.56548, "unit": "s", "result": "pass", "system": "gaya", "partition": "public", "tasks": 2.0, "elements": 40000.0}, {"perfvalue": "elapsed_fill", "value": 2.89716, "unit": "s", "result": "pass", "system": "gaya", "partition": "public", "tasks": 4.0, "elements": 10000.0}, {"perfvalue": "elapsed_compute", "value": 0.0434488, "unit": "s", "result": "pass", "system": "gaya", "partition": "public", "tasks": 4.0, "elements": 10000.0}, {"perfvalue": "elapsed_fill", "value": 36.537, "unit": "s", "result": "pass", "system": "gaya", "partition": "public", "tasks": 4.0, "elements": 20000.0}, {"perfvalue": "elapsed_compute", "value": 0.519222, "unit": "s", "result": "pass", "system": "gaya", "partition": "public", "tasks": 4.0, "elements": 20000.0}, {"perfvalue": "elapsed_fill", "value": 52.302, "unit": "s", "result": "pass", "system": "gaya", "partition": "public", "tasks": 4.0, "elements": 30000.0}, {"perfvalue": "elapsed_compute", "value": 1.23368, "unit": "s", "result": "pass", "system": "gaya", "partition": "public", "tasks": 4.0, "elements": 30000.0}, {"perfvalue": "elapsed_fill", "value": 98.397, "unit": "s", "result": "pass", "system": "gaya", "partition": "public", "tasks": 4.0, "elements": 40000.0}, {"perfvalue": "elapsed_compute", "value": 1.55742, "unit": "s", "result": "pass", "system": "gaya", "partition": "public", "tasks": 4.0, "elements": 40000.0}]
----

[%dynamic%open%hide_code,python]
----
import pandas as pd

master_df = pd.DataFrame.from_dict(records)
----


[%dynamic%open%hide_code,python]
----
master_df.head(5)
----

We can see that this dataframe contains the parameters:
- system
- result
- tasks
- elements
- value
- perfvalue
- unit

By having this common structure, we can make use of transformation strategies to manipulate values depending on the desired output.

Strategies will depend on the figure axis. All strategies will create a pivot dataframe that will contain the parameter specified as `color_axis` as columns, `xaxis` as first level index and `secondary_axis` as second level index. Values of the dataframe will always be the `values` of the master dataframe.

As an example, we will consider the following axis:
[source,json]
----
"xaxis":{
    "parameter":"tasks",
    "label":"Number of tasks"
},
"yaxis":{
    "label":"Execution time (s)"
},
"secondary_axis":{
    "parameter":"elements",
    "label":"N"
},
"color_axis":{
    "parameter":"perfvalue",
    "label":"Performance variable"
}
----

Available strategies are:

- performance

This strategy should be seen as the "base" strategy. No transformation, other that a pivot, is done.
For the given example, it produces the following dataframe

[%dynamic%open%hide_code,python]
----
from feelpp.benchmarking.json_report.figures.transformationFactory import TransformationStrategyFactory
from feelpp.benchmarking.reframe.config.configSchemas import DefaultPlot
plot_config = DefaultPlot(**{
    "title": "Absolute performance",
    "plot_types": [ "stacked_bar", "grouped_bar" ],
    "xaxis":{ "parameter":"tasks", "label":"Number of tasks" },
    "yaxis":{"label":"Execution time (s)"},
    "secondary_axis":{"parameter":"elements", "label":"N"}
})
strategy = TransformationStrategyFactory.create(plot_config)
df = strategy.calculate(master_df)
print(df)
----

- relative_performance

The relative performance strategy computes the proportion of the time that a a `color_axis` variable takes with regards of the total.

[%dynamic%open%hide_code,python]
----
plot_config = DefaultPlot(**{
    "title": "Absolute performance",
    "plot_types": [ "stacked_bar", "grouped_bar" ],
    "transformation": "relative_performance",
    "xaxis":{ "parameter":"tasks", "label":"Number of tasks"
    },
    "yaxis":{"label":"Execution time (s)"},
    "secondary_axis":{ "parameter":"elements", "label":"N"
    }
})
strategy = TransformationStrategyFactory.create(plot_config)
df = strategy.calculate(master_df)
print(df)
----

The sum along the column axis will always be equal to 1.

- speedup

The speedup strategy computes the speedup of the `color_axis` variables. The minimum of the `xaxis` values is taken as the base of the speedup.
For the example, this strategy will produce the following.

[%dynamic%open%hide_code,python]
----
plot_config = DefaultPlot(**{
    "title": "Absolute performance",
    "plot_types": [ "stacked_bar", "grouped_bar" ],
    "transformation": "speedup",
    "xaxis":{"parameter":"tasks", "label":"Number of tasks"},
    "yaxis":{"label":"Execution time (s)"},
    "secondary_axis":{"parameter":"elements", "label":"N"}
})
strategy = TransformationStrategyFactory.create(plot_config)
df = strategy.calculate(master_df)
print(df)
----

== Plot types

Considering the same example axis as above, the software can generate the following figures:

- `scatter`

[%dynamic%open%hide_code,python]
----
from feelpp.benchmarking.json_report.figures.figureFactory import FigureFactory
figures = FigureFactory.create(DefaultPlot(**{
    "title": "Absolute performance - Scatter Plot",
    "plot_types": [ "scatter" ],
    "yaxis":{"label":"Execution time (s)"},
    "secondary_axis":{"parameter":"elements", "label":"N"},
    "xaxis":{"parameter":"tasks", "label":"Number of tasks"}
}))
fig = figures[0].createFigure(master_df)
fig.show()
----

- `marked_scatter`

The marked scatter plot type supports from 2 to 4 dimensions. The symbol/marks axis will correspond to the `secondary_axis` parameter.
This plot type will behave as follows:

* If 1 or 2 dimensions are specified (x-axis and optionally color-axis), then this plot type will be equivalent to `scatter`.
* If 3 dimensions are specified (x-axis, color-axis and secondary-axis), then the `secondary_axis` will correspond to the symbol/marks axis.
* If 4 dimensions are specified (x-axis, color-axis, secondary-axis and one extra-axis), then the first element of the `extra_axes` list will correspond to the symbol/marks axis, and the `secondary_axis` will correspond to the slider of the returned animation.

[%dynamic%open%hide_code,python]
----
figures = FigureFactory.create(DefaultPlot(**{
    "title": "Absolute performance - Marked Scatter Plot",
    "plot_types": [ "marked_scatter" ],
    "yaxis":{"label":"Execution time (s)"},
    "secondary_axis":{"parameter":"elements", "label":"N"},
    "xaxis":{"parameter":"tasks", "label":"Number of tasks"}
}))
fig = figures[0].createFigure(master_df)
fig.show()
----

- `stacked_bar`

[%dynamic%open%hide_code,python]
----
figures = FigureFactory.create(DefaultPlot(**{
    "title": "Absolute performance - Stacked Bar Plot",
    "plot_types": [ "stacked_bar" ],
    "yaxis":{"label":"Execution time (s)"},
    "secondary_axis":{"parameter":"elements", "label":"N"},
    "xaxis":{"parameter":"tasks", "label":"Number of tasks"}
}))
fig = figures[0].createFigure(master_df)
fig.show()
----


- `grouped_bar`

[%dynamic%open%hide_code,python]
----
figures = FigureFactory.create(DefaultPlot(**{
    "title": "Absolute performance - Grouped Bar Plot",
    "plot_types": [ "grouped_bar" ],
    "yaxis":{"label":"Execution time (s)"},
    "secondary_axis":{"parameter":"elements", "label":"N"},
    "xaxis":{"parameter":"tasks", "label":"Number of tasks"}
}))
fig = figures[0].createFigure(master_df)
fig.show()
----

- `heatmap`

For this case, we will consider the `elements` (N) as `color_axis` and `performance_variable` for secondary axis (slider).

[%dynamic%open%hide_code,python]
----
figures = FigureFactory.create(DefaultPlot(**{
    "title": "Absolute performance - HeatMap",
    "plot_types": [ "heatmap" ],
    "yaxis":{"label":"Execution time (s)"},
    "secondary_axis":{"parameter":"perfvalue", "label":"Performance Variable"},
    "xaxis":{"parameter":"tasks", "label":"Number of tasks"},
    "color_axis":{"parameter":"elements", "label":"N"},
}))
fig = figures[0].createFigure(master_df)
fig.show()
----

- `table`

[%dynamic%open%hide_code,python]
----
figures = FigureFactory.create(DefaultPlot(**{
    "title": "Absolute performance - Table",
    "plot_types": [ "table" ],
    "yaxis":{"label":"Execution time (s)"},
    "secondary_axis":{"parameter":"elements", "label":"N"},
    "xaxis":{"parameter":"tasks", "label":"Number of tasks"}
}))
fig = figures[0].createFigure(master_df)
fig.show()
----

- `sunburst`

This figure considers the `color_axis` parameter as the outer-most ring.
Users can supply an `extra_axes` field, containing a list of additional parameters. Values for these parameters whill be shown on the rings that follow the `color_axis` ring, in the order they are provided.
The `secondary_axis` and `xaxis` parameter are present respectively on the inner-most and second inner-most rings.


[%dynamic%open%hide_code,python]
----
figures = FigureFactory.create(DefaultPlot(**{
    "title": "Absolute performance - Sunburst Plot",
    "plot_types": [ "sunburst" ],
    "yaxis":{"label":"Execution time (s)"},
    "secondary_axis":{"parameter":"elements", "label":"N"},
    "xaxis":{"parameter":"tasks", "label":"Number of tasks"}
}))
fig = figures[0].createFigure(master_df)
fig.show()
----


- `parallelcoordinates`

Axes will be shown on the following order: `secondary_axis`, `xaxis`, all additional `extra_axes`, `color_axis`. The `yaxis` will be shown in the line color.

[%dynamic%open%hide_code,python]
----
figures = FigureFactory.create(DefaultPlot(**{
    "title": "Absolute performance - Parallel Coordinates Plot",
    "plot_types": [ "parallelcoordinates" ],
    "yaxis":{"label":"Execution time (s)"},
    "secondary_axis":{"parameter":"elements", "label":"N"},
    "xaxis":{"parameter":"tasks", "label":"Number of tasks"}
}))
fig = figures[0].createFigure(master_df)
fig.show()
----


=== 3D Plots

3D plots are also supported, and then can show up to 4 dimensions. At least 3 parameters must be provided (`xaxis`,`color_axis` and `secondary_axis` ).
Axes correspondance is as follows:

- x-axis of the 3D plot: `xaxis`
- y-axis of the 3D plot: `secondary_axis` if no extra axes are provided, else, the first element of the `extra_axes` list.
- z-axis of the 3D plot: `yaxis` (contains the measured values)
- color of the 3D traces: `color_axis`
- Slider: `secondary_axis` if extra axes are provided.

- `scatter3d`

[%dynamic%open%hide_code,python]
----
figures = FigureFactory.create(DefaultPlot(**{
    "title": "Absolute performance - Scatter 3D",
    "plot_types": [ "scatter3d" ],
    "yaxis":{"label":"Execution time (s)"},
    "secondary_axis":{"parameter":"elements", "label":"N"},
    "xaxis":{"parameter":"tasks", "label":"Number of tasks"}
}))
fig = figures[0].createFigure(master_df)
fig.show()
----

- `surface3d`

[%dynamic%open%hide_code,python]
----
figures = FigureFactory.create(DefaultPlot(**{
    "title": "Absolute performance - Surface 3D",
    "plot_types": [ "surface3d" ],
    "yaxis":{"label":"Execution time (s)"},
    "secondary_axis":{"parameter":"elements", "label":"N"},
    "xaxis":{"parameter":"tasks", "label":"Number of tasks"}
}))
fig = figures[0].createFigure(master_df)
fig.show()
----


== Aggregations

Depending on the dashboard level that we are located at, it might be necessary to aggregate the data on the master dataframe.
For example, if we have all use cases, applications and machines on the dataframe, and we want to see how a certain use case performs on different machines, we can make use of the `aggregations` field to group the data accordingly.

[source,json]
----
"aggregations":[
    {"column":"date","agg":"max"},
    {"column":"applications","agg":"filter:my_app"},
    {"column":"use_cases","agg":"filter:my_use_case"},
    {"column":"performance_variable","agg":"sum"}
]
----

The previous example will first get only the latest benchmarks (by getting the maximum date), then it will filter the application and the use case to find applications and use cases that correspond to "my_app" and "my_use_case". And finally it will compute the sum of all performance variables for the remaining rows.

Users must provide a column and an aggregation function as a string.

Available aggregations are:

- `mean` : Computes the mean of the column
- `mean` : Computes the sum of the column
- `max` : Computes the maximum of the column
- `min` : Computes the minimum of the column
- `filter:value`: Filters the column by `value`.


[NOTE]
====
The order of the aggregations list is important.
====


== Custom layouts

By providing the `layout_modifiers` field, users can pass custom layout options for rendering the figures.
These options correspond to the accepted layout reference for Plotly: https://plotly.com/python/reference/layout/[Plotly layout reference]
It accepts a nested dictionnary just as Plotly does.

For example, we could customize a figure to have have its x-axis on a logscale.
[source,json]
----
"layout_modifiers":{
    "xaxis":{
        "type":"log"
    }
}
----


++++
<style>
details>.title::before, details>.title::after {
    visibility: hidden;
}
details>.content>.dynamic-py-result>.content>pre {
    max-height: 100%;
    padding: 0;
    margin:16px;
    background-color: white;
}
</style>
++++